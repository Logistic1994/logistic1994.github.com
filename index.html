<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <title>Logistic1994&#39;s Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="多写代码">
<meta property="og:type" content="website">
<meta property="og:title" content="Logistic1994's Blog">
<meta property="og:url" content="http://logistic1994.github.io/index.html">
<meta property="og:site_name" content="Logistic1994's Blog">
<meta property="og:description" content="多写代码">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Logistic1994's Blog">
<meta name="twitter:description" content="多写代码">
  
    <link rel="alternative" href="/atom.xml" title="Logistic1994&#39;s Blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" href="/css/style.css" type="text/css">
</head>

<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="./img/author.jpg" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">Logistic1994</a></h1>
		</hgroup>

		
		<p class="header-subtitle">CS. Data Science. Deep Learning. CV.</p>
		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						
						<div class="icon-wrap icon-me hide" data-idx="3">
							<div class="user"></div>
							<div class="shoulder"></div>
						</div>
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>菜单</li>
						<li>標籤</li>
						
						
						<li>關於</li>
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">所有文章</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="https://github.com/Logistic1994" title="github">github</a>
					        
								<a class="weibo" target="_blank" href="http://weibo.com/xiazrong" title="weibo">weibo</a>
					        
								<a class="zhihu" target="_blank" href="https://www.zhihu.com/people/SoSaYifei" title="zhihu">zhihu</a>
					        
								<a class="facebook" target="_blank" href="https://www.facebook.com/logistic.simon" title="facebook">facebook</a>
					        
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/tags/AllowOverride/" style="font-size: 10px;">AllowOverride</a> <a href="/tags/Android/" style="font-size: 13.33px;">Android</a> <a href="/tags/Apache/" style="font-size: 10px;">Apache</a> <a href="/tags/Cluster-analyse/" style="font-size: 10px;">Cluster analyse</a> <a href="/tags/Cluster-analyse/" style="font-size: 10px;">Cluster-analyse</a> <a href="/tags/Experience/" style="font-size: 10px;">Experience</a> <a href="/tags/LR/" style="font-size: 10px;">LR</a> <a href="/tags/LSH/" style="font-size: 10px;">LSH</a> <a href="/tags/Learn/" style="font-size: 20px;">Learn</a> <a href="/tags/LeetCode/" style="font-size: 10px;">LeetCode</a> <a href="/tags/MinHash/" style="font-size: 10px;">MinHash</a> <a href="/tags/Note/" style="font-size: 20px;">Note</a> <a href="/tags/NullPointerError/" style="font-size: 10px;">NullPointerError</a> <a href="/tags/SVM/" style="font-size: 10px;">SVM</a> <a href="/tags/SimHash/" style="font-size: 10px;">SimHash</a> <a href="/tags/Summary/" style="font-size: 10px;">Summary</a> <a href="/tags/Tip/" style="font-size: 10px;">Tip</a> <a href="/tags/dream/" style="font-size: 10px;">dream</a> <a href="/tags/famous/" style="font-size: 10px;">famous</a> <a href="/tags/naive-bayes/" style="font-size: 10px;">naive bayes</a> <a href="/tags/summary/" style="font-size: 20px;">summary</a> <a href="/tags/习惯/" style="font-size: 10px;">习惯</a> <a href="/tags/发现/" style="font-size: 10px;">发现</a> <a href="/tags/我自己/" style="font-size: 20px;">我自己</a> <a href="/tags/机器学习/" style="font-size: 10px;">机器学习</a> <a href="/tags/过拟合/" style="font-size: 10px;">过拟合</a> <a href="/tags/面试/" style="font-size: 16.67px;">面试</a>
					</div>
				</section>
				
				
				

				
				
				<section class="switch-part switch-part3">
				
					<div id="js-aboutme">我是谁，我从哪里来，我到哪里去？我就是我，是颜色不一样的吃货…</div>
				</section>
				
			</div>
		</div>
	</header>				
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">Logistic1994</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
			
				<img lazy-src="./img/author.jpg" class="js-avatar">
			
			</div>
			<hgroup>
			  <h1 class="header-author">Logistic1994</h1>
			</hgroup>
			
			<p class="header-subtitle">CS. Data Science. Deep Learning. CV.</p>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/Logistic1994" title="github">github</a>
			        
						<a class="weibo" target="_blank" href="http://weibo.com/xiazrong" title="weibo">weibo</a>
			        
						<a class="zhihu" target="_blank" href="https://www.zhihu.com/people/SoSaYifei" title="zhihu">zhihu</a>
			        
						<a class="facebook" target="_blank" href="https://www.facebook.com/logistic.simon" title="facebook">facebook</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>

      <div class="body-wrap">
  
    <article id="post-2016年展望" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/02/20/2016年展望/" class="article-date">
  	<time datetime="2016-02-20T10:31:12.000Z" itemprop="datePublished">2016-02-20</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/02/20/2016年展望/">2016年展望</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="2016年一些想法">2016年一些想法</h2><h3 id="工作与学习">工作与学习</h3><p>　　既来之，则安之。毕竟Alibaba也是一个利于个人成长的地方。<br>　　以目前的状态来说，图像领域知识确实非常匮乏。不过也幸好很多需求还是能够现学的。工作的目标是图像和推荐算法，不仅要学术上跟进前沿，工程方面也需要更一步提升。目前状态是作为一个sql工程师是绰绰有余了，但是如果在工程方面更进一步的话，可以考虑实现一些自己个人的项目。</p>
<ol>
<li>sql脚本解析器，Shadowsock免费获取密码集成，人脸特征点检测等等都是需要自己去花时间做的。毕设做的图像检索工具希望也能做成一个能够通用的工具。</li>
<li>Haskell和Scala有待进一步学习。Haskell通过每日一道Codewars题目，Scala直接通过Shadowsock Android版学习。</li>
<li>学会制作精美的ppt和有表现力的图表。</li>
<li>拓扑学。</li>
</ol>
<h3 id="生活">生活</h3><ol>
<li>健身</li>
<li>祛痘美容</li>
<li>增肥</li>
</ol>
<h3 id="书籍和电影">书籍和电影</h3><p>　　好久没有看书了，有空列一个清单。目前先看完《地铁》吧，科幻。<br>　　电影太耗时间了，现在看电影已经缺乏了那种代入感，还是多去电影院看看吧。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/我自己/">我自己</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-Haskell-4" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/09/30/Haskell-4/" class="article-date">
  	<time datetime="2015-09-30T14:45:14.000Z" itemprop="datePublished">2015-09-30</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/09/30/Haskell-4/">Haskell-4</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Monad">Monad</h1>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Learn/">Learn</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Note/">Note</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/Haskell/">Haskell</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-Haskell-3" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/09/26/Haskell-3/" class="article-date">
  	<time datetime="2015-09-26T08:20:14.000Z" itemprop="datePublished">2015-09-26</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/09/26/Haskell-3/">Haskell-3</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Type_Classes_and_Overload">Type Classes and Overload</h1><h2 id="parametric_polymorphism_or_ad_hoc_polymorphism_or_overloading">parametric polymorphism or ad hoc polymorphism or overloading</h2><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">x</span> `elem` [] = <span class="type">False</span></span><br><span class="line"><span class="title">x</span> `elem` (y: ys) = x == y || (x `elem` ys)</span><br></pre></td></tr></table></figure>
<p>如果要求上面 <strong>elem</strong> 的类型是 <strong>a-&gt;[a]-&gt;Bool</strong>，那么我们就必须要求 <strong>==</strong> 的类型是 <strong>a-&gt;a-&gt;Bool</strong>, 但是为什么 <strong>==</strong>的类型会是这样呢？更进一步，如果是两个list进行比较，比较的过程会是什么样子呢？<br>We expect <strong>==</strong> to be overloaded to carry on these various tasks.</p>
<p><em>Type classes</em> allows us to declare which types are <em>instances</em> of which class, and to provide definitions of the overloaded <em>operations</em> associated with a class.<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="type">Eq_</span> a <span class="keyword">where</span></span></span><br><span class="line">    (==) :: a -&gt; a -&gt; <span class="type">Bool</span></span><br></pre></td></tr></table></figure></p>
<p>这里我定义了一个class <strong>Eq_</strong>, 它有一个operation <strong>==</strong>, 其中a是一个type. 应该这样读, “a type <strong>a</strong> is an instance of the class <strong>Eq</strong> if there is an (overloaded) operation <strong>==</strong>, of the appropriate type, defined on it”<br>其中 <strong>Eq_ a</strong>表达了对于 <strong>a</strong>的一个限制，被称为 <strong>context</strong><br>对照上面定义的elem函数, <strong>:type elem</strong> is <strong>elem :: (Eq a) =&gt; a -&gt; [a] -&gt; Bool</strong>, 读作”For every type <strong>a</strong> that is an instance of the class <strong>Eq</strong>, <strong>elem</strong> has type <strong>a-&gt;[a]-&gt;Bool</strong>“<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="typedef"><span class="keyword">data</span> <span class="type">Tree</span> a = </span></span><br><span class="line">    <span class="type">Leaf</span> a | <span class="type">Branch</span> (<span class="type">Tree</span> a) (<span class="type">Tree</span> a)</span><br><span class="line"><span class="class"></span><br><span class="line"><span class="keyword">instance</span> <span class="container">(<span class="type">Eq</span> <span class="title">a</span>)</span> =&gt; <span class="type">Eq</span> <span class="container">(<span class="type">Tree</span> <span class="title">a</span>)</span> <span class="keyword">where</span></span></span><br><span class="line">    <span class="type">Leaf</span> a == <span class="type">Leaf</span> b                    = a == b</span><br><span class="line">    (<span class="type">Branch</span> l1 r1) == (<span class="type">Branch</span> l2 r2)    = (l1 == l2) &amp;&amp; (r1 == r2)</span><br><span class="line">    _ == _                              = <span class="type">False</span></span><br></pre></td></tr></table></figure></p>
<p>其中(Eq a)是必须的，因为比较Leaf时就是直接使用的Leaf的值来进行比较的。</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="type">Eq_</span> a <span class="keyword">where</span></span></span><br><span class="line">    (==), (/=) :: a -&gt; a -&gt; <span class="type">Bool</span></span><br><span class="line">    x /= y = not (x == y)</span><br><span class="line"><span class="comment">-- 那么在继承Eq_的instance中，只要定义了==，那么/=也就定义好了</span></span><br></pre></td></tr></table></figure>
<p><em>class extension</em>, define a class which inherits an existed class<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="container">(<span class="type">Eq_</span> <span class="title">a</span>)</span> =&gt; <span class="type">Ord_</span> a <span class="keyword">where</span></span></span><br><span class="line">    (&lt;), (&lt;=), (&gt;=), (&gt;) :: a -&gt; a -&gt; <span class="type">Bool</span></span><br><span class="line">    max, min :: a -&gt; a -&gt; a</span><br></pre></td></tr></table></figure></p>
<p>We say that Eq<em> is a <em>superclass</em> of Ord</em>, Ord<em> is a <em>subclass</em> of Eq</em>, and any type which is an instance of Ord<em> must also be an instance of Eq</em>.</p>
<p>Class methods共享同一个命名空间，也就是说class methods不能重复。<br>当然，class methods的参数也可以定义除此class的其他参数，比如<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="type">C</span> a <span class="keyword">where</span></span> </span><br><span class="line">    m :: <span class="type">Show</span> b =&gt; a -&gt; b</span><br></pre></td></tr></table></figure></p>
<h2 id="Functor函子">Functor函子</h2><p>第一个例子<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="type">Tofu</span> t <span class="keyword">where</span></span></span><br><span class="line">    tofu:: j a -&gt; t a j</span><br><span class="line"><span class="comment">-- a is *, so j is * -&gt; *, so t is (* -&gt; (* -&gt; *))</span></span><br><span class="line"></span><br><span class="line"><span class="typedef"><span class="keyword">data</span> <span class="type">Frank</span> a b = <span class="type">Frank</span> <span class="container">&#123;<span class="title">frankField</span> :: <span class="title">b</span> <span class="title">a</span>&#125;</span> <span class="keyword">deriving</span> <span class="container">(<span class="type">Show</span>)</span></span></span><br><span class="line"><span class="comment">-- b is *, so a is * -&gt; *</span></span><br><span class="line"><span class="comment">-- the first Frank is data construct </span></span><br><span class="line"><span class="comment">-- the second Frank is type construct</span></span><br><span class="line"><span class="comment">-- the frankField need type *, so a is *, while b is * -&gt; *</span></span><br><span class="line"><span class="class"></span><br><span class="line"><span class="keyword">instance</span> <span class="type">Tofu</span> <span class="type">Frank</span> <span class="keyword">where</span></span></span><br><span class="line">    tofu x = <span class="type">Frank</span> x</span><br><span class="line"><span class="comment">-- tofu need 2 params, the first type is *, while the second is * -&gt; *</span></span><br><span class="line"><span class="comment">-- Frank type just satisfies</span></span><br><span class="line"></span><br><span class="line"><span class="typedef"><span class="keyword">data</span> <span class="type">Barry</span> t k p = <span class="type">Barry</span> <span class="container">&#123;<span class="title">yabba</span>:: <span class="title">p</span>, <span class="title">dabba</span>:: <span class="title">t</span> <span class="title">k</span>&#125;</span> <span class="keyword">deriving</span> <span class="container">(<span class="type">Show</span>)</span></span></span><br><span class="line"><span class="comment">-- p is *</span></span><br><span class="line"><span class="comment">-- k is *, t is *-&gt;*</span></span><br><span class="line"><span class="comment">-- so :k Barry is (*-&gt;*) -&gt; * -&gt; * -&gt; *</span></span><br><span class="line"><span class="comment">-- class Functor f where</span></span><br><span class="line"><span class="comment">--      fmap :: (a-&gt;b) -&gt; f a -&gt; f b</span></span><br><span class="line"><span class="comment">-- a is * , so f needs to be *-&gt;*</span></span><br><span class="line"><span class="comment">-- so while applying Functor onto Barry, the Functor needs (*-&gt;*)</span></span><br><span class="line"><span class="comment">-- we need to fill the first 2 param of Barry</span></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Functor</span> <span class="container">(<span class="type">Barry</span> <span class="title">a</span> <span class="title">b</span>)</span> <span class="keyword">where</span></span></span><br><span class="line">    fmap f (<span class="type">Barry</span> &#123;yabba = x, dabba = y&#125;) = <span class="type">Barry</span> &#123;yabba = f x, dabba = y&#125;</span><br><span class="line"><span class="comment">-- 意思说fmap过来的函数始终只作用在第一个参数yabba上面</span></span><br></pre></td></tr></table></figure></p>
<p>总的意思就是类型的函数，将类型类比为原先的函数中的数值就可以了</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Learn/">Learn</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Note/">Note</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/Haskell/">Haskell</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-Haskell-2" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/09/25/Haskell-2/" class="article-date">
  	<time datetime="2015-09-25T11:32:14.000Z" itemprop="datePublished">2015-09-25</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/09/25/Haskell-2/">Haskell-2</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Case_Expressions_and_Pattern_Matching">Case Expressions and Pattern Matching</h1><p><code>As-patterns</code><br>语法糖<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">f</span> s@(x:xs) = x:s <span class="comment">-- where s means (x:xs)</span></span><br></pre></td></tr></table></figure></p>
<p><code>Wild-cards 通配符</code><br><code>head (x: _) = x</code>, actually we don’t care where <em> is, but in fact, we all know </em> must a list, for <code>:</code> operator has list as its second argument.<br><code>tail (_: x) = x</code></p>
<h2 id="Pattern-Matching_Semantics">Pattern-Matching Semantics</h2><p>匹配时严格按照由左到右，由上而下的顺序进行<br>匹配一般有三种结果 <em>fail, succedd, diverge</em>,比如<code>[1, 2]</code>和<code>[2, bot]</code>进行匹配，则是匹配失败，而<code>[2, 1]</code>和<code>[bot, 2]</code>进行匹配，则是diverge</p>
<p><code>Guard</code><br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">sign</span> x | x &gt; <span class="number">0</span>   = <span class="number">1</span></span><br><span class="line">       | x == <span class="number">0</span>  = <span class="number">0</span></span><br><span class="line">       | x &lt; <span class="number">0</span>   = -<span class="number">1</span></span><br></pre></td></tr></table></figure></p>
<p>其中对于x的条件选择称为<code>Guard</code></p>
<p>Guard的顺序不同可能会引起逻辑顺序不同<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">f</span> x | x &gt; <span class="number">0</span> = <span class="number">1</span></span><br><span class="line">    | x &gt; -<span class="number">1</span> = <span class="number">2</span></span><br><span class="line">    | x &lt;= -<span class="number">1</span> = <span class="number">3</span></span><br><span class="line"><span class="title">f2</span> x | x &gt; -<span class="number">1</span> = <span class="number">2</span></span><br><span class="line">     | x &gt; <span class="number">0</span> = <span class="number">1</span></span><br><span class="line">     | x &lt;= -<span class="number">1</span> = <span class="number">3</span></span><br><span class="line"><span class="comment">-- f 1 结果为 1</span></span><br><span class="line"><span class="comment">-- f2 1 结果为 2</span></span><br></pre></td></tr></table></figure></p>
<p>困难一点的，对于$\perp$<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">bot</span> = bot</span><br><span class="line"></span><br><span class="line"><span class="title">take</span> <span class="number">0</span> _ = []</span><br><span class="line"><span class="title">take</span> _ [] = []</span><br><span class="line"><span class="title">take</span> n (x: xs) = x : take (n-<span class="number">1</span>) xs</span><br><span class="line"></span><br><span class="line"><span class="title">take2</span> _ [] = []</span><br><span class="line"><span class="title">take2</span> <span class="number">0</span> _ = []</span><br><span class="line"><span class="title">take2</span> n (x: xs) = x: take2 (n-<span class="number">1</span>) xs</span><br><span class="line"></span><br><span class="line"><span class="comment">-- take 0 bot = [], bot 匹配上 _， 不需要求值</span></span><br><span class="line"><span class="comment">-- take2 0 bot = $\prep$ 0先匹配上_， bot匹配上[]则发生diverge</span></span><br><span class="line"><span class="comment">-- take bot [] = $\prep$ bot 匹配上0， 发生diverge</span></span><br><span class="line"><span class="comment">-- take2 bot [] = [], bot匹配上_, [] 匹配上[]</span></span><br></pre></td></tr></table></figure></p>
<h2 id="Case_Expressions">Case Expressions</h2><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">take2</span> m ys = <span class="keyword">case</span> (m, ys) <span class="keyword">of</span></span><br><span class="line">            (<span class="number">0</span>, _) -&gt; []</span><br><span class="line">            (_, []) -&gt; []</span><br><span class="line">            (n, x:xs) -&gt; x: take2 (n-<span class="number">1</span>) xs</span><br></pre></td></tr></table></figure>
<p><code>if e1 then e2 else e3</code>也可以看做<code>case e1 of True -&gt; e2 False -&gt; e3</code></p>
<h2 id="Lazy_Patterns_看上去有点吊">Lazy Patterns 看上去有点吊</h2><p>Lazy Patterns are <em>irrefutable</em>: matching a value <em>v</em> against <em>~pat</em> always succeeds, regardless of <em>pat</em>.简单点说就是你参数进来的时候我不看你正不正确，但是如果在等号右边被用到了，那么此时才会去进行match操作，成功或者$\perp$。<br>举个例子<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">reqs</span> = client init_client resps</span><br><span class="line"><span class="title">resps</span> = server reqs</span><br><span class="line"><span class="title">client</span> init_client (resp: resps) = init_client: client (next resp) resps</span><br><span class="line"><span class="title">server</span> (req: reqs) = process req: server reqs</span><br><span class="line"><span class="title">init_client</span> = <span class="number">1</span></span><br><span class="line"><span class="title">next</span> resp = resp * <span class="number">2</span></span><br><span class="line"><span class="title">process</span> req = req + <span class="number">10</span></span><br></pre></td></tr></table></figure></p>
<p>这个程序的意思是，client先发出初始request, <code>init_client</code>，然后server接受request, process它返回response, 接着client使用next对resp进行处理，并发出下一条request，如此循环<br>从逻辑上看，对于<code>resps</code>，在<code>client init_client (resp: resps)</code>的时候，<code>server (req: reqs)</code>并没有知晓，所以<code>resp:resps</code>究竟能否不为空也并不知晓，因此这样的程序存在过早匹配，就是说我们可以将<code>resp:resps</code>先缓一缓在进行匹配</p>
<p>当然传统的改进是这样<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">reqs</span> = client init_client resps</span><br><span class="line"><span class="title">resps</span> = server reqs</span><br><span class="line"><span class="title">client</span> init_client resps = init_client: client (next (head resps)) (tail resps)</span><br><span class="line"><span class="title">server</span> (req: reqs) = process req: server reqs</span><br><span class="line"><span class="title">init_client</span> = <span class="number">1</span></span><br><span class="line"><span class="title">next</span> resp = resp * <span class="number">2</span></span><br><span class="line"><span class="title">process</span> req = req + <span class="number">10</span></span><br></pre></td></tr></table></figure></p>
<p>这样改进，程序肯定能够运行，并且语意上也能懂，就是讲resps只要是个list就肯定能匹配上，至于运行会不会出错，那不关我的事了</p>
<p>lazy pattern的改进是这样的<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">reqs</span> = client init_client resps</span><br><span class="line"><span class="title">resps</span> = server reqs</span><br><span class="line"><span class="title">client</span> init_client ~(resp: resps) = init_client: client (next resp) resps</span><br><span class="line"><span class="title">server</span> (req: reqs) = process req: server reqs</span><br><span class="line"><span class="title">init_client</span> = <span class="number">1</span></span><br><span class="line"><span class="title">next</span> resp = resp * <span class="number">2</span></span><br><span class="line"><span class="title">process</span> req = req + <span class="number">10</span></span><br></pre></td></tr></table></figure></p>
<p>先对<code>resp: resps</code>的非空list的匹配先缓一缓，日后如果匹配上就好，匹配不上就直接为$\perp$值</p>
<p>这个有点绕，需要好好理解一下。</p>
<p>另一个例子是Fibonacci数列。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">fib</span>@(<span class="number">1</span>: tfib) = <span class="number">1</span>: <span class="number">1</span>: [a+b | (a, b) &lt;- zip fib tfib]</span><br></pre></td></tr></table></figure></p>
<p>$fib$ is $[1, 1, 2, 3, 5, 8, 13, \ldots]$<br>$tfib$ is $[1, 2, 3, 5, 8, 13, \ldots]$<br>$[a+b | (a, b) &lt;- zip fib tfib]$ is $[2, 3, 5, 8, 13, \ldots]$<br>$1: 1: [a+b|(a, b) &lt;- zip fib tfib]$ is $[1, 1, 2, 3, 5, 8, 13, \ldots]$ 正好就是$fib$<br>正确性可以得到验证，但是至于它是怎么计算出来的，转换成什么样的汇编就不清楚了<br>从另一个角度来看，这种写法的好处是结尾少一个tail函数。这样的写法叫做<strong>pattern binding</strong>.另外，按照原先的看法是在fib还不知道是什么样子的情况下，莫名地匹配上$1: tfib$的格式，理论上是不会有输出的，但事实上<strong>pattern binding</strong>会自动在fib前面加上<code>~</code>。</p>
<h2 id="Lexical_Scoping_and_Nested_Forms">Lexical Scoping and Nested Forms</h2><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- let 用法</span></span><br><span class="line"><span class="title">f</span> x = <span class="keyword">let</span> y = x * x</span><br><span class="line">    <span class="keyword">in</span> y</span><br></pre></td></tr></table></figure>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- where 用法</span></span><br><span class="line"><span class="title">f</span> x y | y &gt; z = <span class="number">1</span></span><br><span class="line">      | y == z = <span class="number">2</span></span><br><span class="line">      | y &lt; z = <span class="number">3</span></span><br><span class="line">      <span class="keyword">where</span> z = x * x</span><br></pre></td></tr></table></figure>
<p>函数在<code>where</code>绑定中定义的名字只对本函数可见。<code>where</code>绑定不会在多个模式中共享。<code>where</code>绑定可以使用模式匹配。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">initials</span> :: <span class="type">String</span> -&gt; <span class="type">String</span> -&gt; <span class="type">String</span></span><br><span class="line"><span class="title">initials</span> firstname lastname = [f] ++ <span class="string">"."</span> ++ [l] ++ <span class="string">"."</span></span><br><span class="line">  <span class="keyword">where</span> (f:_) = firstname</span><br><span class="line">        (l:_) = lastname</span><br></pre></td></tr></table></figure></p>
<h2 id="有$的函数调用">有$的函数调用</h2><p>$的优先级最低并且是右结合的，所以可以减少括号的写作<br><code>sum (map sqrt[1..130])</code> =&gt; <code>sum $ map sqrt [1..130]</code></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Learn/">Learn</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Note/">Note</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/Haskell/">Haskell</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-Haskell-1" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/09/24/Haskell-1/" class="article-date">
  	<time datetime="2015-09-24T08:53:00.000Z" itemprop="datePublished">2015-09-24</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/09/24/Haskell-1/">Haskell 1</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><em>From “A Gentle Introduction to Haskell 98”</em></p>
<p><strong>学习一门函数式编程，以作为我大学的纪念。</strong></p>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Learn/">Learn</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Note/">Note</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/Haskell/">Haskell</a>
	</div>


      
        <p class="article-more-link">
          <a  href="/2015/09/24/Haskell-1/#more">more >></a>
        </p>
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-Comprehensive-Survey-of-Clustering-Algorithms" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/09/22/Comprehensive-Survey-of-Clustering-Algorithms/" class="article-date">
  	<time datetime="2015-09-22T13:01:23.000Z" itemprop="datePublished">2015-09-22</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/09/22/Comprehensive-Survey-of-Clustering-Algorithms/">Comprehensive Survey of Clustering Algorithms</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>This paper is <a href="http://link.springer.com/article/10.1007/s40745-0150-040-1" title="A Comprehensive Survey of Clustering Algorithms" target="_blank" rel="external">A Comprehensive Survey of Clustering Algorithms</a>.</p>
<h2 id="Classic_definition_of_clusering">Classic definition of clusering</h2><ol>
<li>Instances, in the same cluster, must be similar as much as possible</li>
<li>Instances, in the different clusters, must be different as much as possitble</li>
<li>Measurement for similarity and dissimilarity must be clear and have the practical meaning</li>
</ol>
<h2 id="Standard_process_of_clustering">Standard process of clustering</h2><ol>
<li>Feature extraction and selection: extract and select the most <strong>representative</strong> features</li>
<li>Clustering algorithm design</li>
<li>Result evaluation</li>
<li>Result explanation</li>
</ol>
<h2 id="Internal_evaluation_indicators">Internal evaluation indicators</h2><ol>
<li>Davies-Bouldin<br>$$<br>DB=\frac{1}{k}\sum_{i=1}^k{max_{i\neq j}\left(\frac{\sigma_i + \sigma_j}{d(c_i + c_j)}\right)}<br>$$</li>
<li>Dunn indicator<br>There must be some errors.</li>
</ol>
<p><strong>To-do</strong></p>
<ol>
<li>understand Mahalanobis distance, $\sqrt{(x_i - x_j)^T S^{-1} (x_i - x_j)}$, where S is the covariance matrix inside the cluster</li>
<li>one of the similarity functions, for data of mixed type, map the feature into (0, 1), transform the fature into dichotomous one $S_{ij}=\frac{1}{d} \sum_{l=1}^d{S_{ijl}}$</li>
<li></li>
</ol>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Cluster-analyse/">Cluster-analyse</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/summary/">summary</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/Machine-Learning/">Machine Learning</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-面试总结" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/09/17/面试总结/" class="article-date">
  	<time datetime="2015-09-17T08:11:13.000Z" itemprop="datePublished">2015-09-17</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/09/17/面试总结/">面试总结</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="2015面试总结">2015面试总结</h1><h3 id="阿里">阿里</h3><ul>
<li>2015.3 数据岗电面<br>  一面直接挂，总的来说就是我在平时学习中对于很多东西的总结不够，比如怎么解释特征，比如除了kmeans之外的一些其他聚类算法。幸运的是此时我的简历还没上去，就当是磨练了吧。</li>
<li>2015.4 淘宝技术部现场群面<br>  需要能说出自己想表达的东西，我发现还是边画图写代码边说更适合我。总结什么的我真的不能说。</li>
<li>2015.4~5 实习生电面，一共6面<br>  最煎熬的一段时间，还好算法复习的不错，而且项目经验也说的很溜。</li>
<li>2015.8 转正面试<br>  真的应该好好准备。<strong>能做出好的ppt真的是一件很好的事情。</strong>平时做事情的时候对于业务上的思考与总结也很重要。</li>
<li>2015.9 转正交叉面试<br>  <strong>算法要能够温故而知新!</strong></li>
</ul>
<h3 id="百度">百度</h3><ul>
<li>2015.9 笔试<br>  笔试比较简单，受益于在阿里的实习，对于一些业务上的细节把握的不错。</li>
<li>2015.9 一面<br>  很顺利，最重要的是面试官是一线做算法的人，学到的东西也很多</li>
<li>2015.9 二面<br>  有点结巴。比如 <strong>LR模型</strong>的一些东西就给忘了，有些东西在脑子里呢，可是名字死活记不得，基础不够牢固啊！</li>
</ul>
<h3 id="腾讯">腾讯</h3><ul>
<li>2015.9 一面<br>  西八。腾讯的做算法的太屌了，都是博士生，你一个本科生还是老老实实写代码做工程去吧。感觉在腾讯做工程的人都瞧不起学历小于等于自己的做算法的。你做的那些算法都是别人做剩下的。唉，压力不小啊！</li>
<li>2015.9 二面<br>  西八。我写了一个归并排序后直接走人。屌丝程序猿何苦为难屌丝程序猿呢？</li>
</ul>
<h3 id="百度作业帮">百度作业帮</h3><ul>
<li>2015.9 一面<br>  主要还是项目经验，一些基础的算法以及两道编程题。编程题挺有意思的。<br>  第一道是防止DDOS的题。给定一系列的访问数据，要求给出在一定范围内时间访问次数超过N次的一些IP。解法是不考虑内存的循环队列。<br>  第二道是DNN输出的找出TopN。</li>
<li>2015.9 二面<br>  项目经验和一些简单的算法。</li>
</ul>
<h3 id="购物党">购物党</h3><ul>
<li>西八。还招不招人啊，两个小时做4道工程类编程题以及6到业务题。有病!</li>
</ul>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/面试/">面试</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/总结/">总结</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-Experience-of-data-science" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/09/14/Experience-of-data-science/" class="article-date">
  	<time datetime="2015-09-14T15:51:56.000Z" itemprop="datePublished">2015-09-14</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/09/14/Experience-of-data-science/">Experience of data science</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>Original post is <a href="http://www.csdn.net/article/2015-09-10/2825668" title="关于数据科学，书上不曾提及的三点经验" target="_blank" rel="external">关于数据科学，书上不曾提及的三点经验</a>.</p>
</blockquote>
<p>Algorithms are important as we all know. But in practice, we should never know how such an algorithm is coded, for they all have been packed already. Most of us even have never implemented such complex toys, such as SVM etc. So what really counts?</p>
<h2 id="Evaluation_Methods">Evaluation Methods</h2><p>Our models could be invalid at any time! If simply getting half of dataset to be trainning set, while others to be test set, most of time we could get good models. But when data is sensitive to time, or other things, models can be very werid. For example, dresses are hot in June, cold in Feb.</p>
<p>At the other case, when there is high correlationship among the dataset, Stock as an example… we all know. </p>
<p>So we should get evaluation methods as good as possible, just to avoid some worst cases.</p>
<h2 id="Feature_Engineering">Feature Engineering</h2><p>Models are simple even <strong>ugly</strong> tools for TB-level data.<br>Features are arts.<br>Features are arts.<br>Features are arts.<br>(Important things should be repeated for 3 times.)</p>
<h2 id="Model_parameters_should_spend_most_of_the_time">Model parameters should spend most of the time</h2><p><strong>I should need more time to understand that.</strong></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Experience/">Experience</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Summary/">Summary</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/Machine-Learning/">Machine Learning</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-LeetCode-happy-number" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/09/13/LeetCode-happy-number/" class="article-date">
  	<time datetime="2015-09-13T05:30:20.000Z" itemprop="datePublished">2015-09-13</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/09/13/LeetCode-happy-number/">LeetCode_happy_number</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="Description">Description</h2><blockquote>
<p>A happy number is a number defined by the following process: Starting with any positive integer, replace the number by the sum of the squares of its digits and repeat the process until the number equals 1(where it will stay), or it loops endlessly in a cycle which does not include 1. Those numbers for which this process ends in 1 are happy numbers.<br><strong>Example</strong>: 19 is a happy number<br>$$<br>1^2 + 9^2 = 82 \\<br>8^2 + 2^2 = 68 \\<br>6^2 + 8^2 = 100 \\<br>1^2 + 0^2 + 0^2 = 1<br>$$</p>
</blockquote>
<h2 id="Solution">Solution</h2><p>It is very easy to solve. At the first beginning, i was thinking about how to identify if one number had already existed. So i use HashMap. But the solution time is not so gratifying.</p>
<p>One day later, I found such behavior of the sequence: if numbers are not happy, it will follow such sequence as follows:<br>$$<br>4, 16, 37, 58, 89, 145, 42, 20, 4, \ldots<br>$$</p>
<p>Beautiful!</p>
<h2 id="Code">Code</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isHappy</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum;</span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line">    <span class="keyword">while</span> (sum != <span class="number">1</span>) &#123;</span><br><span class="line">        sum = <span class="number">0</span>;</span><br><span class="line">        temp = n;</span><br><span class="line">        <span class="keyword">while</span> (temp != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> factor = temp / <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">int</span> remainer = temp - <span class="number">10</span> * factor;</span><br><span class="line">            sum += (remainer * remainer);</span><br><span class="line">            temp = factor;</span><br><span class="line">        &#125;</span><br><span class="line">        n = sum;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">4</span> || n == <span class="number">16</span> || n == <span class="number">37</span> || n == <span class="number">58</span> || n == <span class="number">89</span> || n == <span class="number">145</span> || n == <span class="number">42</span> || n == <span class="number">20</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/LeetCode/">LeetCode</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/LeetCode/">LeetCode</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-LR与naive bayes的区别" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/09/11/LR与naive bayes的区别/" class="article-date">
  	<time datetime="2015-09-11T06:20:36.000Z" itemprop="datePublished">2015-09-11</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/09/11/LR与naive bayes的区别/">LR与naive bayes的区别</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="相同点">相同点</h2><ol>
<li>都是对特征的线性表达<br>$$\sum_j \theta_j x_j$$<br>区别在与两者所fit的parameters不同</li>
<li>都是通过条件概率建模<br>$$P(y=k|x)$$</li>
</ol>
<h2 id="不同点">不同点</h2><ol>
<li>LR对于特征间的相关性不会像naive bayes那么敏感，所以LR在特征工程方面的工作量会少一点</li>
<li>naive bayes没有优化参数这一步，什么样的模型就出来什么样的结果</li>
<li>LR是判别模型，而naive bayes是生成模型，生成模型在有prior数据的情况下效果会更好</li>
</ol>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/LR/">LR</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/naive-bayes/">naive bayes</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/summary/">summary</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/Machine-Learning/">Machine Learning</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
  
    <nav id="page-nav">
      <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
    </nav>
  
</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2016 Logistic1994
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" type="text/css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: true,
		isPost: false,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>
<script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js" type="text/javascript"></script>
<script src="/js/main.js" type="text/javascript"></script>






<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  </div>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
</body>
</html>